goodColor <- c("pink", "gold", "darkseagreen", "firebrick4", "lightskyblue", "orange1", "lightyellow", "royalblue", "moccasin","violet", "olivedrab3", "blueviolet", "yellow2", "darkgreen", "royalblue4", "lightsalmon3", "mediumaquamarine", "coral1",  "darkolivegreen1", "cyan4", "tan4", "grey80")
goodColor2 <-  c("black","#DF536B","#61D04F","#2297E6","#28E2E5","#CD0BBC","#F5C710","gray62")
goodColor3 <- c("black", "#CD0BBC", "pink", "gold", "darkseagreen", "firebrick4", "lightskyblue", "orange1", "lightyellow", "royalblue", "moccasin","violet", "olivedrab3", "blueviolet", "yellow2", "darkgreen", "royalblue4", "lightsalmon3", "mediumaquamarine", "coral1",  "darkolivegreen1", "cyan4", "tan4", "grey80")


plot_colors <- function(color_names) {
  n <- length(color_names)
  plot(1:n, rep(1, n), pch = 19, cex = 2, col = color_names, xaxt = 'n', yaxt = 'n', xlab = '', ylab = '')
  text(1:n, rep(1.5, n), labels = color_names, srt = 90, cex = 0.6, adj = c(1, 0.5))
}


assign_colors <- function(df, column, palette) {
  unique_values <- unique(df[, column])
  n <- length(unique_values)
  if (n > length(palette)) {
    warning("Not enough colors in the palette for all unique values; some colors will be reused.")
  }
  # Repeat the palette if there are not enough colors
  color_assignments <- palette[1:n]
  names(color_assignments) <- unique_values
  return(color_assignments)
}

#' Plot Event Tree
#'
#' This function generates a visual representation of an event tree using the provided edge event table
#' and tree structure. The tree is plotted with edges labeled by event information and nodes colored
#' by their type (normal or tumor). The function returns both the graph object and the plot for further
#' customization or analysis.
#'
#' @param edge_event_table A data frame containing edge event information. This is typically generated by the
#'   `create_edge_event_table` function:
#'        \itemize{
#'          \item edge_name: Edge identifier ("parent_child" format)
#'          \item edge_label: Event labels for the edge
#'          \item n_events: Number of events on the edge
#'        }
#' @param tree An igraph tree object representing the phylogenetic structure
#'
#' @return A list containing two elements:
#'         \itemize{
#'           \item graph_ob: The igraph object with added event information
#'           \item tree_plot: A ggplot2 object showing the rendered tree
#'         }
#'
#' @details
#' The function performs these steps:
#' 1. Converts tree to edge list format
#' 2. Creates node table with clone types (normal/tumor)
#' 3. Merges edge event information with tree structure
#' 4. Creates a dendrogram layout visualization with:
#'    - Edges labeled with copy number events
#'    - Nodes colored by clone type
#'    - Node labels showing clone names
#'
#' @note
#' The visualization uses:
#' - Node size of 20
#' - Text size of 5
#' - Grey edges
#' - 2.5mm label dodge for edge labels
#' - void theme for clean background
#'
#' @examples
#' \dontrun{
#' library(igraph)
#' library(ggraph)
#'
#' # Create sample tree and edge events
#' tree <- make_tree(3, 2)
#' edge_events <- create_edge_event_table(your_events, tree)
#'
#' # Create plot
#' result <- plot_event_tree(edge_events, tree)
#' print(result$tree_plot)
#' }
#'
#' @importFrom igraph graph_from_data_frame V as_edgelist
#' @importFrom ggraph ggraph geom_edge_link geom_node_point geom_node_text
#' @importFrom ggplot2 theme_void
#' @export
plot_event_tree <- function(edge_event_table, tree) {
  # Generate the tree table
  tree_table <- data.frame(as_edgelist(tree))
  colnames(tree_table) <- c("parent", "child")
  tree_table$edge_name <- paste(tree_table$parent, tree_table$child, sep = "_")

  # Generate the node table
  node_table <- cbind(clone_name = V(tree)$name, clone_type = c("normal", rep("tumor", length(V(tree)) - 1)))

  # Create the graph object
  merge_df_colnames <- c("parent", "child","edge_name", "edge_label", "n_events")
  graph_ob <- graph_from_data_frame(
    merge(tree_table, edge_event_table, by = "edge_name", all.x = TRUE)[,merge_df_colnames],
    node_table,
    directed = TRUE
  )

  tree_plot <- ggraph(graph_ob, layout = 'dendrogram', length = n_events) +
    geom_edge_link(aes(label = edge_label),
                   label_dodge = unit(2.5, 'mm'),
                   color = "grey") +
    geom_node_point(size = 20, aes(colour = clone_type)) +
    geom_node_text(aes(label = name), size = 5) +
    theme_void()

  return(list(graph_ob = graph_ob, tree_plot = tree_plot))
}

#' Create Chromosome Bar Annotation for ComplexHeatmap
#'
#' @description
#' Creates a chromosome bar annotation track for ComplexHeatmap visualization, which includes
#' alternating black and grey bars to distinguish chromosomes and chromosome number labels.
#' The function handles both standard (22 autosomes + X, Y) and custom chromosome sets.
#'
#' @param window_data A data frame containing genomic window information with at least one
#'        column named 'chr' (case-insensitive) containing chromosome identifiers
#'        (e.g., "chr1", "chr2", etc.).
#'
#' @return A HeatmapAnnotation object from the ComplexHeatmap package containing:
#'         \itemize{
#'           \item A text annotation track with chromosome numbers
#'           \item A binary pattern track with alternating black and grey bars
#'         }
#'
#' @details
#' The function performs the following steps:
#' \itemize{
#'   \item Standardizes chromosome column names to lowercase
#'   \item Computes chromosome lengths and boundaries
#'   \item Creates alternating binary pattern for visual separation
#'   \item Calculates mean positions for chromosome labels
#'   \item Generates chromosome text annotations
#' }
#'
#' @examples
#' \dontrun{
#' # Create sample window data
#' window_data <- data.frame(
#'   chr = rep(paste0("chr", c(1:22, "X")), each = 100),
#'   start = 1:2300,
#'   end = 101:2400
#' )
#'
#' # Generate chromosome bar annotation
#' chr_annotation <- draw_chr_bar(window_data)
#'
#' # Use in ComplexHeatmap
#' library(ComplexHeatmap)
#' Heatmap(matrix_data,
#'         top_annotation = chr_annotation)
#' }
#'
#' @importFrom ComplexHeatmap HeatmapAnnotation anno_text
#' @importFrom grid gpar
#'
#' @export
draw_chr_bar <- function(window_data) {

  # Standardize column names to lowercase
  colnames(window_data) <- tolower(colnames(window_data))

  # Compute chromosome lengths
  chromosome_data <- window_data
  chr_bin_nums <- rle(gsub('chr', '', window_data$chr))$lengths

  # Retrieve exact # of chromosomes, 22 or 23 might be typical for whole genome level data
  n_chr = length(chr_bin_nums)

  # Calc binary patterns for chr bar annotation
  if (n_chr %% 2 == 0) {
    num_pairs = n_chr / 2
    binary_pattern <- c(rep(c(2, 1), num_pairs))
  } else {
    num_pairs = (n_chr - 1) / 2
    binary_pattern <- c(rep(c(2, 1), num_pairs), 2)
  }

  # Create binary pattern data frame, derive exact
  bin_binary_patterns <- rep.int(x = binary_pattern, times = chr_bin_nums)
  bin_indices_at_chr_bounds <- c(1, cumsum(chr_bin_nums))

  # Calculate mean positions for chromosome annotations
  chr_bounds_df <- data.frame(
    start_bin_indices = bin_indices_at_chr_bounds[1:length(bin_indices_at_chr_bounds) - 1],
    end_bin_indices = bin_indices_at_chr_bounds[2:length(bin_indices_at_chr_bounds)]
  )
  chr_segment_mean_pos <- round(rowMeans(chr_bounds_df))

  # Chromosome names for annotation
  chromosome_names <- c(1:22, "X", "Y")[1:n_chr]


  # Prepare vector for chromosome number annotations
  annotation_vector <- vector(length = sum(chr_bin_nums), mode = "character")
  suppressWarnings(annotation_vector[chr_segment_mean_pos] <- chromosome_names)

  # Create chromosome bar annotation for heatmap
  chromosome_bar_annotation <- ComplexHeatmap::HeatmapAnnotation(
    chromosome_text = ComplexHeatmap::anno_text(annotation_vector, gp = grid::gpar(fontsize = 14)),
    binary_pattern = as.character(bin_binary_patterns),
    show_legend = FALSE,
    show_annotation_name = FALSE,
    which = "column",
    col = list(binary_pattern = c("1" = "grey88", "2" = "black"))
  )

  return(chromosome_bar_annotation)
}



#' Plot Copy Number Heatmap with Clone Identity Annotations
#'
#' @description
#' Creates a ComplexHeatmap visualization of copy number data across genomic coordinates,
#' with annotations for clone identities and chromosome locations. The function specifically
#' handles integer copy number states and includes customizable color schemes.
#'
#' @param seg_dat A numeric matrix containing segmented copy number data, where rows
#'        represent cells and columns represent genomic windows
#' @param title Character string specifying the title for the heatmap
#' @param clone_identity_vector A vector specifying clone assignments for each cell (row)
#' @param clone_color_anno A named vector of colors for clone annotation
#' @param chr_bar A HeatmapAnnotation object for chromosome visualization (typically
#'        created by draw_chr_bar function)
#' @param integer_col Logical indicating whether to treat data as integer copy numbers
#'        (TRUE) or continuous values (FALSE)
#' @param max_int Integer specifying the maximum copy number state to display. Values
#'        above this will be shown as NA (default: 8)
#'
#' @return Draws a ComplexHeatmap visualization and invisibly returns the Heatmap object
#'
#' @details
#' The function creates a heatmap with the following features:
#' \itemize{
#'   \item Left annotation showing clone identities
#'   \item Top annotation showing chromosome boundaries
#'   \item Custom color scheme for integer copy numbers using ocean.balance palette
#'   \item NA values (including values > max_int) shown in yellow
#'   \item Non-clustered visualization preserving genomic order
#' }
#'
#' @examples
#' \dontrun{
#' # Create sample data
#' seg_data <- matrix(sample(0:8, 1000, replace = TRUE), nrow = 20)
#' clone_ids <- rep(c("Clone1", "Clone2"), each = 10)
#' clone_colors <- c("Clone1" = "red", "Clone2" = "blue")
#'
#' # Create chromosome bar annotation
#' chr_bar <- draw_chr_bar(window_data)
#'
#' # Plot heatmap
#' plot_truth_heatmap(
#'   seg_dat = seg_data,
#'   title = "Copy Number Profile",
#'   clone_identity_vector = clone_ids,
#'   clone_color_anno = clone_colors,
#'   chr_bar = chr_bar,
#'   integer_col = TRUE,
#'   max_int = 8
#' )
#' }
#'
#' @importFrom ComplexHeatmap Heatmap rowAnnotation draw
#' @importFrom grid gpar
#' @importFrom pals ocean.balance
#'
#' @seealso
#' \code{\link{draw_chr_bar}} for creating chromosome bar annotations
#'
#' @export
plot_truth_heatmap <- function(seg_dat, title, clone_identity_vector, clone_color_anno, chr_bar, integer_col, max_int = 8){
  # set params for complex heatmap
  complex_args <- list(
    use_raster = FALSE,
    raster_quality = 2,
    col = NULL,
    bottom_annotation = NULL,
    right_annotation = NULL,
    left_annotation = rowAnnotation(clones = clone_identity_vector, col = list(clones = clone_color_anno)),
    column_title = "genomic coordinates",
    column_title_gp = grid::gpar(fontsize = 16),
    column_title_side = "bottom",
    row_title = paste0(length(clone_identity_vector), " cells"),
    row_title_gp = grid::gpar(fontsize = 18),
    top_annotation = chr_bar,
    cluster_rows = FALSE,
    border = TRUE,
    cluster_columns = FALSE,
    show_column_names = FALSE,
    show_row_names = FALSE,
    show_heatmap_legend = TRUE
  )


  if(integer_col == TRUE){

    complex_args <- complex_args[which(names(complex_args) != 'col')]

    seg_dat[seg_dat > max_int] = NA

    color_heat <-
      structure(ocean.balance(length(0:max_int)),
                names = 0:max_int
      )

    heatmap_plot <- do.call(

      ComplexHeatmap::Heatmap,
      c(
        list(
          matrix = seg_dat,
          #   left_annotation = cluster_anno,
          heatmap_legend_param = list(title = "CN"),
          col = color_heat,
          na_col = "yellow"
        ),
        complex_args
      )
    )

    draw(heatmap_plot, column_title = title, column_title_gp = grid::gpar(fontsize = 18))
  }
}

plot_multi_anno_heatmap <- function(seg_dat, title, clone_identity_df, clone_color_anno_list, chr_bar, integer_col, max_int = 8){
  # set params for complex heatmap
  complex_args <- list(
    use_raster = FALSE,
    raster_quality = 2,
    col = NULL,
    bottom_annotation = NULL,
    right_annotation = NULL,
    column_title = "genomic coordinates",
    column_title_gp = grid::gpar(fontsize = 16),
    column_title_side = "bottom",
    row_title = paste0(nrow(clone_identity_df), " cells"),
    row_title_gp = grid::gpar(fontsize = 18),
    top_annotation = chr_bar,
    cluster_rows = FALSE,
    border = TRUE,
    cluster_columns = FALSE,
    show_column_names = FALSE,
    show_row_names = FALSE,
    show_heatmap_legend = TRUE
  )

  # create annotation bar
  cluster_anno <-
    ComplexHeatmap::rowAnnotation(
      df = clone_identity_df,
      col = clone_color_anno_list,
      show_annotation_name = FALSE
    )

  if(integer_col == TRUE){

    complex_args <- complex_args[which(names(complex_args) != 'col')]

    seg_dat[seg_dat > max_int] = NA

    color_heat <-
      structure(ocean.balance(length(0:max_int)),
                names = 0:max_int
      )
    heatmap_plot <- do.call(

      ComplexHeatmap::Heatmap,
      c(
        list(
          matrix = seg_dat,
          left_annotation = cluster_anno,
          heatmap_legend_param = list(title = "CN"),
          col = color_heat,
          na_col = "yellow"
        ),
        complex_args
      )
    )

    draw(heatmap_plot, column_title = title, column_title_gp = grid::gpar(fontsize = 18))



  }
}

#' Generate Mock Window Data
#'
#' This function creates a mock data frame containing chromosome information extracted from
#' the column names of a matrix. The column names are expected to be in the format
#' `chromosome_start_end`, and the function extracts the chromosome part to create the
#' `chr` column in the resulting data frame.
#'
#' @description
#' Creates a simple data frame containing chromosome information extracted from
#' genomic window identifiers (matrix column names in "chr_start_end" format).
#'
#' @param matrix_colnames A character vector of column names in the format
#'        "chr_start_end" (e.g., "chr1_1000_2000")
#'
#' @return A data frame with one column:
#'         \itemize{
#'           \item chr: Character vector containing chromosome names extracted from input
#'         }
#'
#' @details
#' The function:
#' 1. Splits each column name by "_"
#' 2. Extracts the first element (chromosome name)
#' 3. Creates a data frame with these chromosome names
#'
#' @examples
#' \dontrun{
#' col_names <- c("chr1_1000_2000", "chr1_2000_3000", "chr2_1000_2000")
#' window_data <- generate_mock_window_data(col_names)
#' # Returns data frame:
#' #   chr
#' # 1 chr1
#' # 2 chr1
#' # 3 chr2
#' }
#'
#' @export
generate_mock_window_data <- function(matrix_colnames) {
  # Extract the chromosome part from the column names
  chr_parts <- sapply(strsplit(matrix_colnames, "_"), `[`, 1)

  # Create a dataframe with a 'chr' column containing these chromosome parts
  window_data <- data.frame(chr = chr_parts)

  return(window_data)
}


